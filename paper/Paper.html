<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>The Application of Systems Science and Electrical Engineering Topics in Quantitative
Finance</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="Paper.tex"> 
<meta name="date" content="2013-12-13 11:30:00"> 
<link rel="stylesheet" type="text/css" href="Paper.css"> 
</head><body 
>
<div class="maketitle">
                                                                                         
                                                                                         
                                                                                         
                                                                                         

<h2 class="titleHead">The Application of Systems Science and Electrical
Engineering Topics in Quantitative Finance</h2>
<div class="author" ><span 
class="ecrm-1440">Andrew Clayton Hess &amp; Desmond Robert Duggan</span></div>
<br />
<div class="date" ><span 
class="ecrm-1440">December 13, 2013</span></div>
                                                                                         
                                                                                         
</div>
                                                                                         
                                                                                         
<h2 class="likechapterHead"><a 
 id="x1-1000"></a>Abstract</h2>
<!--l. 82--><p class="noindent" >This project explores mathematical topics commonly found in systems science and engineering and
electrical engineering, and applies them to analyzing financial instruments. Topics explored include
moving averages, Kalman Filtering, Linear Model, Wiener Filtering, and dithering.
Fundamental ideas from each topic were modified to analyze financial instruments and
ultimately assess how each might be useful for devising an automated trading strategy.
Each topic was implemented in Python and uses the NumPy and SciPy libraries for
advanced computation. Results show that some of the filters provide good insight at a very
fundamental implementation, and when put into more advanced programs, may be extremely
successful.
                                                                                         
                                                                                         
<h2 class="likechapterHead"><a 
 id="x1-2000"></a>Contents</h2> <div class="tableofcontents">
<span class="chapterToc" >1 <a 
href="#x1-30001" id="QQ2-1-3">Introduction and Background</a></span>
<br />&#x00A0;<span class="sectionToc" >1.1 <a 
href="#x1-40001.1" id="QQ2-1-4">Background</a></span>
<br />&#x00A0;<span class="sectionToc" >1.2 <a 
href="#x1-50001.2" id="QQ2-1-5">Problem Statement</a></span>
<br /><span class="chapterToc" >2 <a 
href="#x1-60002" id="QQ2-1-6">Experiment Overview</a></span>
<br />&#x00A0;<span class="sectionToc" >2.1 <a 
href="#x1-70002.1" id="QQ2-1-7">Application of Systems Science and Electrical Engineering Topics</a></span>
<br />&#x00A0;<span class="sectionToc" >2.2 <a 
href="#x1-80002.2" id="QQ2-1-8">Trading Simulation</a></span>
<br /><span class="chapterToc" >3 <a 
href="#x1-90003" id="QQ2-1-10">Double Moving Average</a></span>
<br />&#x00A0;<span class="sectionToc" >3.1 <a 
href="#x1-100003.1" id="QQ2-1-11">Theory</a></span>
<br />&#x00A0;<span class="sectionToc" >3.2 <a 
href="#x1-110003.2" id="QQ2-1-12">Design</a></span>
<br />&#x00A0;<span class="sectionToc" >3.3 <a 
href="#x1-120003.3" id="QQ2-1-13">Results</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >3.3.1 <a 
href="#x1-130003.3.1" id="QQ2-1-14">Trading Simulation Specifications</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >3.3.2 <a 
href="#x1-140003.3.2" id="QQ2-1-15">Net Profit</a></span>
<br />&#x00A0;<span class="sectionToc" >3.4 <a 
href="#x1-150003.4" id="QQ2-1-18">Evaluation</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >3.4.1 <a 
href="#x1-160003.4.1" id="QQ2-1-19">Choice of (<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub>, <span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub>)</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >3.4.2 <a 
href="#x1-170003.4.2" id="QQ2-1-20">Conclusions</a></span>
<br /><span class="chapterToc" >4 <a 
href="#x1-180004" id="QQ2-1-21">The Wiener Filter</a></span>
<br />&#x00A0;<span class="sectionToc" >4.1 <a 
href="#x1-190004.1" id="QQ2-1-22">Theory</a></span>
<br />&#x00A0;<span class="sectionToc" >4.2 <a 
href="#x1-200004.2" id="QQ2-1-23">Design</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.2.1 <a 
href="#x1-210004.2.1" id="QQ2-1-24">Strict Step Size</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.2.2 <a 
href="#x1-220004.2.2" id="QQ2-1-25">Relaxed Step Size</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.2.3 <a 
href="#x1-230004.2.3" id="QQ2-1-26">Remark</a></span>
<br />&#x00A0;<span class="sectionToc" >4.3 <a 
href="#x1-240004.3" id="QQ2-1-27">Results</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.3.1 <a 
href="#x1-250004.3.1" id="QQ2-1-28">Trading Simulation Specifications</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.3.2 <a 
href="#x1-260004.3.2" id="QQ2-1-29">Net Profit</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.3.3 <a 
href="#x1-270004.3.3" id="QQ2-1-32">Predicted Price vs. Actual Price</a></span>
<br />&#x00A0;<span class="sectionToc" >4.4 <a 
href="#x1-300004.4" id="QQ2-1-39">Evaluation</a></span>
                                                                                         
                                                                                         
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.4.1 <a 
href="#x1-310004.4.1" id="QQ2-1-40">Strict versus Relaxed Step Size</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.4.2 <a 
href="#x1-320004.4.2" id="QQ2-1-41">Short versus Long Step Size</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.4.3 <a 
href="#x1-330004.4.3" id="QQ2-1-42">Regarding the Validity of the Strict Implementation</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >4.4.4 <a 
href="#x1-340004.4.4" id="QQ2-1-43">Assessment of Trading Strategy</a></span>
<br /><span class="chapterToc" >5 <a 
href="#x1-350005" id="QQ2-1-44">The Kalman Filter</a></span>
<br />&#x00A0;<span class="sectionToc" >5.1 <a 
href="#x1-360005.1" id="QQ2-1-45">Theory</a></span>
<br />&#x00A0;<span class="sectionToc" >5.2 <a 
href="#x1-370005.2" id="QQ2-1-46">Design</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >5.2.1 <a 
href="#x1-380005.2.1" id="QQ2-1-47">Alpha-Beta-Gamma Filter Equations</a></span>
<br />&#x00A0;<span class="sectionToc" >5.3 <a 
href="#x1-390005.3" id="QQ2-1-48">Results</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >5.3.1 <a 
href="#x1-400005.3.1" id="QQ2-1-49">Trading Simulation Specifications</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >5.3.2 <a 
href="#x1-410005.3.2" id="QQ2-1-50">Net Profit</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >5.3.3 <a 
href="#x1-420005.3.3" id="QQ2-1-53">Predicted Price vs. Actual Price</a></span>
<br />&#x00A0;<span class="sectionToc" >5.4 <a 
href="#x1-430005.4" id="QQ2-1-56">Evaluation</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >5.4.1 <a 
href="#x1-440005.4.1" id="QQ2-1-57">Choice of <span 
class="cmmi-12">&#x03B1; </span></a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >5.4.2 <a 
href="#x1-450005.4.2" id="QQ2-1-59">Conclusions</a></span>
<br /><span class="chapterToc" >6 <a 
href="#x1-460006" id="QQ2-1-60">Linear Estimation</a></span>
<br />&#x00A0;<span class="sectionToc" >6.1 <a 
href="#x1-470006.1" id="QQ2-1-61">Theory</a></span>
<br />&#x00A0;<span class="sectionToc" >6.2 <a 
href="#x1-480006.2" id="QQ2-1-62">Design</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >6.2.1 <a 
href="#x1-490006.2.1" id="QQ2-1-63">Linear Model Example</a></span>
<br />&#x00A0;<span class="sectionToc" >6.3 <a 
href="#x1-500006.3" id="QQ2-1-64">Results</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >6.3.1 <a 
href="#x1-510006.3.1" id="QQ2-1-65">Trading Simulation Specifications</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >6.3.2 <a 
href="#x1-520006.3.2" id="QQ2-1-66">Net Profit</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >6.3.3 <a 
href="#x1-530006.3.3" id="QQ2-1-69">Predicted Price vs. Actual Price</a></span>
<br />&#x00A0;<span class="sectionToc" >6.4 <a 
href="#x1-540006.4" id="QQ2-1-72">Evaluation</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >6.4.1 <a 
href="#x1-550006.4.1" id="QQ2-1-73">Effect of filter length </a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >6.4.2 <a 
href="#x1-560006.4.2" id="QQ2-1-76">Time Complexity Trade-Offs</a></span>
<br />&#x00A0;&#x00A0;<span class="subsectionToc" >6.4.3 <a 
href="#x1-570006.4.3" id="QQ2-1-77">Feasibility as an estimator</a></span>
<br /><span class="chapterToc" >7 <a 
href="#x1-580007" id="QQ2-1-78">Conclusions</a></span>
<br />&#x00A0;<span class="sectionToc" >7.1 <a 
href="#x1-590007.1" id="QQ2-1-79">Algorithm Comparison</a></span>
<br /><span class="chapterToc" >8 <a 
href="#x1-610008" id="QQ2-1-82">Code</a></span>
<br />&#x00A0;<span class="sectionToc" >8.1 <a 
href="#x1-620008.1" id="QQ2-1-83">Alpha Beta Gamma Filter</a></span>
</div>
                                                                                         
                                                                                         
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;1</span><br /><a 
 id="x1-30001"></a>Introduction and Background</h2>
<h3 class="sectionHead"><span class="titlemark">1.1   </span> <a 
 id="x1-40001.1"></a>Background</h3>
<!--l. 102--><p class="noindent" >In 2009, it was estimated that quantitative trading firms, which represented 2% of the
number of trading firms operating in US markets, accounted for around 70% of all equity
trading volume <span class="cite">[<a 
href="#Xkey-2">WallStreetAndTech</a>]</span>. Although this number has since decreased, it
demonstrates the extraordinary growth in quantitative finance that was experienced in the last
decade.
<!--l. 108--><p class="noindent" >Such fast paced growth was facilitated by major advancements in communications systems
that took place in parallel. Computers have vastly decreased communication times and
eliminated much of the simple arbitrage that existed since the inception of the capital
markets.
<!--l. 113--><p class="noindent" >Many orders placed by these firms are executed with pre-programmed electronic instructions that
are designed by mathematically inclined traders. The content of these instructions is a highly
guarded secret within each firm, and it&#8217;s often the case that an algorithm has a limited
lifetime where it is able to take advantage of discovered arbitrage opportunities before the
markets adjust or other firms develop similar strategies and the opportunity is minimized
<span class="cite">[<a 
href="#Xkey-3">AlgorithmicTrading</a>]</span>.
<!--l. 121--><p class="noindent" >This project is concerned with how topics in systems science and electrical engineering
may be applied to this industry. Many topics such as control theory, signal processing
and optimization are relevant to high frequency trading. Engineers who study systems
science often seek to discover the signal through the noise or optimize a constrained
mathematical model. Similarly, traders seek to optimize their portfolios and discover arbitrage
opportunities.
<!--l. 130--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">1.2   </span> <a 
 id="x1-50001.2"></a>Problem Statement</h3>
<!--l. 132--><p class="noindent" >Analyze the effectiveness of various systems science and electrical engineering prediction methods
in tracking the price of financial instruments in the stock market.
                                                                                         
                                                                                         
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;2</span><br /><a 
 id="x1-60002"></a>Experiment Overview</h2>
<h3 class="sectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-70002.1"></a>Application of Systems Science and Electrical Engineering Topics</h3>
<!--l. 142--><p class="noindent" >In this paper, we explore the following systems science and electrical engineering topics:
<!--l. 145--><p class="noindent" ><span 
class="ecbx-1200">1. Double Moving Average</span>
<!--l. 147--><p class="noindent" >The double moving average algorithm is a widely known, simple example of an algorithmic trading
strategy. It works by trading an equity when its short and long moving averages cross, thereby
indicating momentum.
<!--l. 152--><p class="noindent" ><span 
class="ecbx-1200">2. Wiener Filter</span>
<!--l. 154--><p class="noindent" >The wiener filter is an algorithm that seeks to filter out noise in order to estimate the true
underlying signal. The method assumes the signal is a linear stochastic process with
known autocorrelation and seeks to minimize the error between the actual signal and its
measurements.
<!--l. 159--><p class="noindent" ><span 
class="ecbx-1200">3. The Kalman Filter</span>
<!--l. 161--><p class="noindent" >The Kalman Filter is a recursive algorithm that uses measurements observed over time to predict
the value of future measurements. It has been proven to be an effective estimator for many real
world applications. However, the Kalman Filter requires a mathematical model for the
system it tracks. In this project we implement a simplified version of the Kalman Filter
called the Alpha-Beta-Gamma Filter, which does not require a rigorous mathematical
model.
<!--l. 169--><p class="noindent" ><span 
class="ecbx-1200">4. Linear Prediction Model</span>
<!--l. 171--><p class="noindent" >In this project, a linear prediction model is used to estimate future financial instrument prices by
training on recent historical data. This model works by using 1000 historical data points to predict
1 future point.
<!--l. 177--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.2   </span> <a 
 id="x1-80002.2"></a>Trading Simulation</h3>
<!--l. 179--><p class="noindent" >For this project, we constructed a trading simulator in Python, a highly versatile dynamically
typed programming language. We define a Trade Algorithm as the highest level object in the
simulation. Each Trade Algorithm is initialized with an estimator type, price history for a single
financial instrument and an empty Portfolio Object with $100,000 of starting capital. Then the
simulation is run over the price history, making trades based on the projected price in the following
time step.
<!--l. 188--><p class="noindent" ><span 
class="ecbx-1200">List of Trading Simulation Data Structures</span>
           <dl class="list1"><dt class="list">
TradeAlgorithm </dt><dd 
class="list">
           <!--l. 190--><p class="noindent" >Top level controller for the trading simulation, executes the trading strategy.
                                                                                         
                                                                                         
           </dd><dt class="list">
Portfolio   </dt><dd 
class="list">
           <!--l. 192--><p class="noindent" >Maintains current available capital and a list of assets.
           </dd><dt class="list">
Asset      </dt><dd 
class="list">
           <!--l. 193--><p class="noindent" >An object unique to each financial instrument that maintains how many units
           are owned in the Portfolio.
           </dd><dt class="list">
Order      </dt><dd 
class="list">
           <!--l. 195--><p class="noindent" >A small data structure to facilitate transactions.</dd></dl>
<!--l. 197--><p class="noindent" ><hr class="figure"><div class="figure" 
><a 
 id="x1-8001r1"></a> <img 
src="0_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_diagram.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;2.1: </span><span  
class="content">Data Structures</span></div><!--tex4ht:label?: x1-8001r1 -->
<!--l. 201--><p class="noindent" ></div><hr class="endfigure">
<!--l. 204--><p class="noindent" ><span 
class="ecbx-1200">Summarized Simulation Procedure</span>
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-8003x1">Initialize TradeAlgorithm with price history and algorithm type.
      </li>
      <li 
  class="enumerate" id="x1-8005x2">Iterate over the price history.
      </li>
      <li 
  class="enumerate" id="x1-8007x3">Note the current price and calculate the projected price using one of the estimators.
      </li>
      <li 
  class="enumerate" id="x1-8009x4">If the projected price is greater than the current price, place a &#8220;BUY&#8221; order for 1 unit
      at the current price. If the projected price is less than the current price, place a &#8220;SELL&#8221;
      order at the current price.
      </li>
      <li 
  class="enumerate" id="x1-8011x5">Once the all of the data has been processed, sell all remaining assets at the last noted
      price.</li></ol>
                                                                                         
                                                                                         
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;3</span><br /><a 
 id="x1-90003"></a>Double Moving Average</h2>
<h3 class="sectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-100003.1"></a>Theory</h3>
<!--l. 223--><p class="noindent" >A moving average is an average taken from a subset of a time-series of data. It is calculated
between the current time and a predetermined window going <span 
class="cmmi-12">j </span>steps back. As time
advances, this average changes as the subset adds more current values and removes older
ones. A plot of the moving average over time can reveal some valuable insight regarding
the long term performance of a financial instrument as opposed to the small random
fluctuations observed on a step-by-step basis. Moving averages have been used to analyze
financial instruments for quite some time, with a common method being the double moving
average.
<!--l. 233--><p class="noindent" >For a double moving average algorithm, there are two windows of different sizes. Comparing the
difference between the two averages indicates not only the long term performance of the
instrument, but it can affectively provide a prediction as to how that instrument will perform. If an
instrument started increasing in value, the shorter window would increase at a rate faster than the
longer window as there are fewer samples to consider. Knowing this, a simple algorithm
can be written to buy a financial instrument whenever the shorter window crosses and
becomes greater than the longer window; in the opposite situation, the algorithm would
sell.
<!--l. 244--><p class="noindent" >The concepts used in this algorithm may be basic, but they have proven to be successful and are
widely popular in quantitative finance. Although it is not a topic practically seen in systems
science or electrical engineering, this algorithm is still worth exploring and will also be great for
comparison.
<!--l. 251--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">3.2   </span> <a 
 id="x1-110003.2"></a>Design</h3>
<!--l. 253--><p class="noindent" >Implementing the moving average is extremely simple. The algorithm has inputs of long and short
windows (<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub> and <span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub> ]), and it continually calculates each moving average as time progresses.
Since a trade decision is only made if the moving averages cross, only the averages from the
previous step need to be stored in memory. The program calculates the difference between the
averages (<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub> <span 
class="cmsy-10x-x-120">-</span><span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub> ), and if the previous difference was positive and the current is negative, a buy
will be ordered. A sell will be ordered under the opposite conditions; nothing occurs under
consistent conditions.
<!--l. 264--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">3.3   </span> <a 
 id="x1-120003.3"></a>Results</h3>
                                                                                         
                                                                                         
<!--l. 267--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">3.3.1   </span> <a 
 id="x1-130003.3.1"></a>Trading Simulation Specifications</h4>
<!--l. 268--><p class="noindent" >
           <dl class="list1"><dt class="list">
Data      </dt><dd 
class="list">
           <!--l. 269--><p class="noindent" >Equity price history
           </dd><dt class="list">
Period/Freq </dt><dd 
class="list">
           <!--l. 270--><p class="noindent" >1 year at 10 minute resolution. ~9000 data points per equity
           </dd><dt class="list">
Stocks     </dt><dd 
class="list">
           <!--l. 272--><p class="noindent" >Ford (F), Apple (AAPL), Accenture (ACN), Caterpillar (CAT), Macy&#8217;s (M),
           United Parcel Service (UPS), Priceline (PCLN), Campbell Soup Company (CPB)
           </dd><dt class="list">
Starting-capital </dt><dd 
class="list">
           <!--l. 275--><p class="noindent" >$100,000 (<span 
class="cmmi-12">C</span><sub><span 
class="cmmi-8">i</span></sub>)
           </dd><dt class="list">
<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub>        </dt><dd 
class="list">
           <!--l. 276--><p class="noindent" >50, 200 steps
           </dd><dt class="list">
<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub>        </dt><dd 
class="list">
           <!--l. 277--><p class="noindent" >25, 100 steps</dd></dl>
<!--l. 279--><p class="noindent" >Many window sizes were initially explored, but the (<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub>, <span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub>) combinations of (25, 50) and (100,
200) consistently showed the most promising results.
<!--l. 284--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">3.3.2   </span> <a 
 id="x1-140003.3.2"></a>Net Profit</h4>
<!--l. 286--><p class="noindent" >Net profit is calculated by taking the value of all cash and equity holdings (<span 
class="cmmi-12">A</span>) and subtracting the
starting capital ($100,000).
<center class="par-math-display" >
<img 
src="Paper0x.png" alt="P =  A - C
           i
" class="par-math-display" ></center>
                                                                                         
                                                                                         
<!--l. 291--><p class="nopar" >
<!--l. 294--><p class="noindent" >The following graphs are comparisons between the net profit achieved by running the
Double Moving Averages algorithm on the two different window sets, (25, 50) and (100,
200).
<!--l. 298--><p class="noindent" ><span 
class="ecbx-1200">Graph of Net Profit where </span>(<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub>, <span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub>) = (25, 50)
<!--l. 300--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-14001r1"></a>
                                                                                         
                                                                                         

<!--l. 301--><p class="noindent" ><img 
src="1_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_dma-25-50.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;3.1: </span><span  
class="content">Net Profit Realized in Simulation with (<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub>, <span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub>) = (25, 50)</span></div><!--tex4ht:label?: x1-14001r1 -->
                                                                                         
                                                                                         
<!--l. 305--><p class="noindent" ></div><hr class="endfigure">
<!--l. 308--><p class="noindent" >The only notable success came from AAPL, which gave a return of $245.38. CAT also had a
small gain of $15.99. The other stocks all lost a small amount, the most being PCLN at
$25.33. Total returns on each of these stocks were $208.81, mostly due to the success from
AAPL.
<!--l. 313--><p class="noindent" ><span 
class="ecbx-1200">Graph of Total Net Returns where </span>(<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub>, <span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub>) = (100, 200)
<!--l. 316--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-14002r2"></a>
                                                                                         
                                                                                         

<!--l. 317--><p class="noindent" ><img 
src="2_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_dma-100-200.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;3.2: </span><span  
class="content">Net Profit Realized in Simulation with (<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub>, <span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub>) = (100, 200)</span></div><!--tex4ht:label?: x1-14002r2 -->
                                                                                         
                                                                                         
<!--l. 321--><p class="noindent" ></div><hr class="endfigure">
<!--l. 324--><p class="noindent" >Again, AAPL performed well, but not the same performance seen previously as returns
shrank to $104.95. CAT also had a smaller gain of $8.51. The other stocks again lost a
small amount, except PCLN now lost $98.31. Total returns on each of these stocks were
-$20.12; AAPL and PCLN offset each other and the slight losses from the others added
up.
<h3 class="sectionHead"><span class="titlemark">3.4   </span> <a 
 id="x1-150003.4"></a>Evaluation</h3>
<!--l. 334--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">3.4.1   </span> <a 
 id="x1-160003.4.1"></a>Choice of (<span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">l</span></sub>, <span 
class="cmmi-12">W</span><sub><span 
class="cmmi-8">s</span></sub>)</h4>
<!--l. 336--><p class="noindent" >Choosing the length of each window is critical to the outcome of each simulation. In addition to
the shown simulations of (25, 50) and (100, 200), simulations were done with windows at shorter
and longer ranges as well as at different proportions. At a glance, these two achieved the best
results, and coincidentally both have a short to long window ratio of <span 
class="cmr-12">1 : 2</span>. Windows set to a very
short distance performed very poorly, while very long lengths were only slightly worse than the
ones used.
<!--l. 346--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">3.4.2   </span> <a 
 id="x1-170003.4.2"></a>Conclusions</h4>
<!--l. 348--><p class="noindent" >The Double Moving Average algorithm shows some promising signs, but at its fundamental
implementation, it is not something that can consistently make for a good strategy. However, a
more thorough implementation could show dramatic improvements. Using windows of very short
length make the calculations change much more quickly, which causes the algorithm
to make more aggressive, sometimes stupid decisions. A very long window can make
it slow to react to important changes. Windows of medium length showed the best
results.
                                                                                         
                                                                                         
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;4</span><br /><a 
 id="x1-180004"></a>The Wiener Filter</h2>
<h3 class="sectionHead"><span class="titlemark">4.1   </span> <a 
 id="x1-190004.1"></a>Theory</h3>
<!--l. 363--><p class="noindent" >A Wiener Filter is a type of filter that seeks to filter out noise and give an estimation of the true
underlying signal. It is commonly used in audio and image processing to remove the
noise from a signal or image, respectively. It was developed in the 1940s by Norbert
Wiener and published in 1949, but Andrey Kolmogorov also provided significant additions
towards its development. Its success gave rise to many other filters, including the Kaman
Filter.
<!--l. 371--><p class="noindent" >The Wiener Filter was initially developed for use in continuous time and a non causal case,
meaning both past and future data needed to be accessible. Some variations of the Wiener filter
that make it more valuable are the continuous time causal solution as well as the discrete time
causal solution, otherwise known as the finite impulse response (FIR) Wiener Filter.
This variation takes in a finite amount of past and present data and can be used to
either determine the underlying signal or to make a prediction of the next value. The
FIR Wiener Filter assumes that the signal is a linear stochastic process with known
autocorrelation and it seeks to minimize the error between the actual signal and its
prediction. This error minimization technique makes it very similar to a least squares
method.
<!--l. 384--><p class="noindent" >For this experiment, an FIR Wiener Filter will be used to predict the future states of financial
instruments. The equation below shows how a prediction will be made at each successive
state:
<center class="par-math-display" >
<img 
src="Paper1x.png" alt="       &#x2211;n
&#x02C6;Xi+1 =     &#x03C9;kXi- k
       k=0
" class="par-math-display" ></center>
<!--l. 390--><p class="nopar" >
<!--l. 393--><p class="noindent" >The prediction for the next state is calculated by taking the sum of the product of an ideal weight,
<span 
class="cmmi-12">&#x03C9;</span><sub><span 
class="cmmi-8">k</span></sub>, and the <span 
class="cmmi-12">k</span><sup><span 
class="cmmi-8">th</span></sup> previous value from the present state. This means that the Wiener Filter has a
variable filter length that determines the amount of previous data to consider in calculations. Each
<span 
class="cmmi-12">&#x03C9; </span>represents the weighted value that minimized the error in prediction of previous states. Let
<span 
class="cmmi-12">W </span>be the array that contains each <span 
class="cmmi-12">&#x03C9; </span>going back <span 
class="cmmi-12">k </span>values from the current state such
that <span 
class="cmmi-12">&#x03C9;</span><sub><span 
class="cmmi-8">k</span></sub> represents the ideal weight for the current state. <span 
class="cmmi-12">W </span>can then be calculated as
follows:
<center class="par-math-display" >
<img 
src="Paper2x.png" alt="       -1
W  = R x rdx
" class="par-math-display" ></center>
                                                                                         
                                                                                         
<!--l. 406--><p class="nopar" >
<!--l. 409--><p class="noindent" >Where <span 
class="cmmi-12">R</span><sub><span 
class="cmmi-8">x</span></sub> is a <span 
class="cmmi-12">k </span>x <span 
class="cmmi-12">k </span>Hermitian Toeplitz matix of autocorrelations and <span 
class="cmmi-12">r</span><sub><span 
class="cmmi-8">dx</span></sub> is a vector of
cross-correlations. Each <span 
class="cmmi-12">&#x03C9; </span>within <span 
class="cmmi-12">W </span>is the ideal weight for its respective state in time. The
equation below shows that <span 
class="cmmi-12">&#x03C9;</span><sub><span 
class="cmmi-8">k</span></sub> is the value of the weight that produces the smallest value of the
squared difference between the prediction and true value.
<center class="par-math-display" >
<img 
src="Paper3x.png" alt="                &#x02C6;            2
&#x03C9;k =  argmin {(Xk+1  - Xk+1 ) }
" class="par-math-display" ></center>
<!--l. 418--><p class="nopar" >
<!--l. 422--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">4.2   </span> <a 
 id="x1-200004.2"></a>Design</h3>
<!--l. 424--><p class="noindent" >The Wiener Filter is implemented in Python and uses the Numpy library. Instead of using
the Hermitian Toeplitz matix of autocorrelations and vector of cross-correlations to
calculate the ideal value for each <span 
class="cmmi-12">&#x03C9;</span>, an two alternative implementations were devised.
These methods were developed solely for a simpler implementation and they still seek to
minimize error from predictions in previous states. The program finds the optimal value for
<span 
class="cmmi-12">&#x03C9;</span><sub><span 
class="cmmi-8">k</span></sub> that minimizes the prediction error for state <span 
class="cmmi-12">t </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">k </span><span 
class="cmr-12">+ 1 </span>for <span 
class="cmmi-12">k </span><span 
class="cmr-12">= 1 </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">k</span>. Both of the
final prediction calculations use array <span 
class="cmmi-12">W</span>, which consists of different valued weights
<span 
class="cmmi-12">&#x03C9;</span><sub><span 
class="cmmi-8">k</span></sub>.
<!--l. 436--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">4.2.1   </span> <a 
 id="x1-210004.2.1"></a>Strict Step Size</h4>
<!--l. 438--><p class="noindent" >Running a prediction with a step size of <span 
class="cmmi-12">n </span>at time <span 
class="cmmi-12">t </span>will only use points within the range of <span 
class="cmmi-12">t </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">n</span>
for generating the values of each <span 
class="cmmi-12">&#x03C9;</span>. This causes the initial summation calculations to use fewer
values than the later ones as the step window is strictly defined. As each <span 
class="cmmi-12">&#x03C9;</span><sub><span 
class="cmmi-8">k</span></sub> is calculated, it is
continually used in calculating all consecutive values of <span 
class="cmmi-12">&#x03C9;</span>. The program then adjusts
the values of a value <span 
class="cmmi-12">w </span>and determines which value will continually keep error at a
minimum.
<center class="par-math-display" >
<img 
src="Paper4x.png" alt="          n&#x2211;-1
X&#x02C6;t- k+1 =     &#x03C9;kXt -k + wXt -n
          k=0
" class="par-math-display" ></center>
                                                                                         
                                                                                         
<!--l. 449--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper5x.png" alt="&#x03C9;k = argmin { (X &#x02C6;t -k+1 - Xt- k+1)2}
" class="par-math-display" ></center>
<!--l. 454--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper6x.png" alt="        n
&#x02C6;      &#x2211;
Xt+1 =     &#x03C9;kXt- k
       k=0
" class="par-math-display" ></center>
<!--l. 459--><p class="nopar" >
<!--l. 463--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">4.2.2   </span> <a 
 id="x1-220004.2.2"></a>Relaxed Step Size</h4>
<!--l. 465--><p class="noindent" >In this variation, each <span 
class="cmmi-12">&#x03C9; </span>calculation always uses <span 
class="cmmi-12">n </span>points of previous data for calculating the
optimal weight. For the previous <span 
class="cmmi-12">k </span>states leading up to <span 
class="cmmi-12">t</span>, the program incrementally increases the
value of an arbitrary variable <span 
class="cmmi-12">w </span>multiplied by the <span 
class="cmmi-12">j </span><span 
class="cmr-12">= </span><span 
class="cmmi-12">k </span>previous states. When calculating what
these values should be, the same objective function is used, but it uses a fixed weight <span 
class="cmmi-12">w </span>across each
previous state. For each state of <span 
class="cmmi-12">k</span>, <span 
class="cmmi-12">w </span>is incrementally increased and the value that produces the
least squared error is then assigned to be that respective <span 
class="cmmi-12">&#x03C9;</span><sub><span 
class="cmmi-8">k</span></sub>. This is shown in the equations
below:
<center class="par-math-display" >
<img 
src="Paper7x.png" alt="           n
X&#x02C6;     =  &#x2211;  wX
  t- k+1    k=0    t-k-j
" class="par-math-display" ></center>
<!--l. 477--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper8x.png" alt="&#x03C9;k = argmin { (X &#x02C6;t -k+1 - Xt- k+1)2}
" class="par-math-display" ></center>
<!--l. 482--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper9x.png" alt="        n
&#x02C6;      &#x2211;
Xt+1 =     &#x03C9;kXt- k
       k=0
" class="par-math-display" ></center>
<!--l. 487--><p class="nopar" >
<!--l. 491--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">4.2.3   </span> <a 
 id="x1-230004.2.3"></a>Remark</h4>
<!--l. 493--><p class="noindent" >Both implementations were given a desired level of precision for calculating the desired
values of <span 
class="cmmi-12">&#x03C9;</span>, but a heuristic was written to significantly reduce the number of iterations
needed.
<!--l. 498--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">4.3   </span> <a 
 id="x1-240004.3"></a>Results</h3>
<!--l. 501--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">4.3.1   </span> <a 
 id="x1-250004.3.1"></a>Trading Simulation Specifications</h4>
<!--l. 502--><p class="noindent" >
           <dl class="list1"><dt class="list">
Data      </dt><dd 
class="list">
           <!--l. 503--><p class="noindent" >Equity price history
           </dd><dt class="list">
Period/Freq </dt><dd 
class="list">
           <!--l. 504--><p class="noindent" >1 year at 10 minute resolution. ~9000 data points per equity
           </dd><dt class="list">
Stocks     </dt><dd 
class="list">
           <!--l. 506--><p class="noindent" >Ford (F), Apple (AAPL), Accenture (ACN), Caterpillar (CAT), Macy&#8217;s (M),
           United Parcel Service (UPS), Priceline (PCLN), Campbell Soup Company (CPB)
           </dd><dt class="list">
Starting-capital </dt><dd 
class="list">
           <!--l. 509--><p class="noindent" >$100,000 (<span 
class="cmmi-12">C</span><sub><span 
class="cmmi-8">i</span></sub>)
                                                                                         
                                                                                         
           </dd><dt class="list">
<span 
class="cmmi-12">n</span>          </dt><dd 
class="list">
           <!--l. 510--><p class="noindent" >10 and 40
           </dd><dt class="list">
Experiments </dt><dd 
class="list">
           <!--l. 511--><p class="noindent" >Testing performance of both strict and relaxed step length</dd></dl>
<!--l. 515--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">4.3.2   </span> <a 
 id="x1-260004.3.2"></a>Net Profit</h4>
<!--l. 517--><p class="noindent" >Net profit is calculated by taking the value of all cash and equity holdings (<span 
class="cmmi-12">A</span>) and subtracting the
starting capital ($100,000).
<center class="par-math-display" >
<img 
src="Paper10x.png" alt="P =  A - Ci
" class="par-math-display" ></center>
<!--l. 522--><p class="nopar" >
<!--l. 525--><p class="noindent" >The following is a comparison of the net profits achieved from both variations of the Wiener Filter
with against nine equities at 2 different step sizes.
<!--l. 529--><p class="noindent" ><span 
class="ecbx-1200">Graph of Net Profit where </span><span 
class="cmmi-12">n </span><span 
class="cmr-12">= 10</span>
<!--l. 531--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-26001r1"></a>
                                                                                         
                                                                                         

<!--l. 532--><p class="noindent" ><img 
src="3_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_wiener-prof-10.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4.1: </span><span  
class="content">Net Profits Realized in Simulation with <span 
class="cmmi-12">n </span><span 
class="cmr-12">= 10</span></span></div><!--tex4ht:label?: x1-26001r1 -->
                                                                                         
                                                                                         
<!--l. 535--><p class="noindent" ></div><hr class="endfigure">
<!--l. 538--><p class="noindent" >The strict step size (blue) did not achieve any profits, but aside from PCLN, it also did not have
any huge losses. The relaxed step size (red) was able to achieve a small profit on CAT, but it had
huge losses on AAPL, ACN, PCLN, and CPB.
<!--l. 543--><p class="noindent" ><span 
class="ecbx-1200">Graph of Net Profit where </span><span 
class="cmmi-12">n </span><span 
class="cmr-12">= 40</span>
<!--l. 545--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-26002r2"></a>
                                                                                         
                                                                                         

<!--l. 546--><p class="noindent" ><img 
src="4_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_wiener-prof-40.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4.2: </span><span  
class="content">Net Profits Realized in Simulation with <span 
class="cmmi-12">n </span><span 
class="cmr-12">= 40</span></span></div><!--tex4ht:label?: x1-26002r2 -->
                                                                                         
                                                                                         
<!--l. 549--><p class="noindent" ></div><hr class="endfigure">
<!--l. 552--><p class="noindent" >The strict step size (blue) was able to achieve a considerable profit of $10,698.05 on AAPL, but
returned a loss of $13,936.80 on PCLN. All other stocks had small losses of a few hundred dollars.
The relaxed step size (red) had similar results, but again at a much larger scale. Gains
from AAPL were a surprising $27,933.73, while PCLN managed to lose $23,454.91. The
other stocks again had less considerable losses, but now were amplified by an order of
magnitude.
<h4 class="subsectionHead"><span class="titlemark">4.3.3   </span> <a 
 id="x1-270004.3.3"></a>Predicted Price vs. Actual Price</h4>
<!--l. 563--><p class="noindent" >The ultimate success of this algorithm can be measured by how accurately the filter is able to
predict future price movements. This can be affected by the differences between the relaxed and
strict step requirements as well as the number of steps used. In this section, a small section of data
from the simulation of UPS will be analyzed to understand how accurately the Wiener Filter can
predict the next price.
<!--l. 571--><p class="noindent" >
<h5 class="subsubsectionHead"><span class="titlemark">4.3.3.1   </span> <a 
 id="x1-280004.3.3.1"></a>Strict Step Size</h5>
<!--l. 573--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with </span><span 
class="cmmi-12">n </span><span 
class="cmr-12">= 10</span>
<!--l. 575--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-28001r3"></a>
                                                                                         
                                                                                         

<!--l. 576--><p class="noindent" ><img 
src="5_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_wiener-pred-strict-10.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4.3: </span><span  
class="content">Comparison of Predicted vs. Actual Values with <span 
class="cmmi-12">n </span><span 
class="cmr-12">= 10</span></span></div><!--tex4ht:label?: x1-28001r3 -->
                                                                                         
                                                                                         
<!--l. 579--><p class="noindent" ></div><hr class="endfigure">
<!--l. 582--><p class="noindent" >In the graph above, it is very clear that the short, strict step size is able to model the stock price to
a high level of accuracy. For the majority of this segment, the prediction is almost exactly
equivalent to the actual outcome. There were a few cases when the Wiener Filter overestimates
a movement. The blue spikes indicate a time when it predicted a much higher result
while the red trench indicates a point when the prediction was much lower than reality.
However, there are very few cases when the price moves in the opposite direction of the
prediction.
<!--l. 592--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with </span><span 
class="cmmi-12">n </span><span 
class="cmr-12">= 40</span>
<!--l. 594--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-28002r4"></a>
                                                                                         
                                                                                         

<!--l. 595--><p class="noindent" ><img 
src="6_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_wiener-pred-strict-40.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4.4: </span><span  
class="content">Comparison of Predicted vs. Actual Values with<span 
class="cmmi-12">n </span><span 
class="cmr-12">= 40</span></span></div><!--tex4ht:label?: x1-28002r4 -->
                                                                                         
                                                                                         
<!--l. 598--><p class="noindent" ></div><hr class="endfigure">
<!--l. 601--><p class="noindent" >The graph above shows that with a longer step size, the strict step implementation still produces
incredible results. Predictions consistently follow the slight fluctuations of the actual price, and
only twice in this segment did it overestimate a movement.
<h5 class="subsubsectionHead"><span class="titlemark">4.3.3.2   </span> <a 
 id="x1-290004.3.3.2"></a>Relaxed Step Size</h5>
<!--l. 609--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with </span><span 
class="cmmi-12">n </span><span 
class="cmr-12">= 10</span>
<!--l. 611--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-29001r5"></a>
                                                                                         
                                                                                         

<!--l. 612--><p class="noindent" ><img 
src="7_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_wiener-pred-relaxed-10.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4.5: </span><span  
class="content">Comparison of Predicted vs. Actual Values with <span 
class="cmmi-12">n </span><span 
class="cmr-12">= 10</span></span></div><!--tex4ht:label?: x1-29001r5 -->
                                                                                         
                                                                                         
<!--l. 615--><p class="noindent" ></div><hr class="endfigure">
<!--l. 618--><p class="noindent" >In the relaxed implementation with a short step size, it is clear that it does not have the
same level of performance as the strict implementation. In addition to inaccurately
predicting large movements as seen by the two spikes, it was also consistently slightly above
of below the actual price. This data shows that it is slow to pick up on price changes
and struggles to have a prediction match the true value, yet alone the direction it will
move.
<!--l. 626--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with </span><span 
class="cmmi-12">n </span><span 
class="cmr-12">= 40</span>
<!--l. 628--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-29002r6"></a>
                                                                                         
                                                                                         

<!--l. 629--><p class="noindent" ><img 
src="8_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_wiener-pred-relaxed-40.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4.6: </span><span  
class="content">Comparison of Predicted vs. Actual Values with <span 
class="cmmi-12">n </span><span 
class="cmr-12">= 40</span></span></div><!--tex4ht:label?: x1-29002r6 -->
                                                                                         
                                                                                         
<!--l. 632--><p class="noindent" ></div><hr class="endfigure">
<!--l. 635--><p class="noindent" >With a larger step size, the results are completely unreliable. The longer step size makes it
overcompensate for any slight movement, causing the predicted value to violently shift around. The
large blue mountain and red valley represent a predicted increase and decrease that never occurred.
This data shows that with a larger step, the relaxed Wiener Filter has much more volatile,
inaccurate predictions.
<h3 class="sectionHead"><span class="titlemark">4.4   </span> <a 
 id="x1-300004.4"></a>Evaluation</h3>
<!--l. 646--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">4.4.1   </span> <a 
 id="x1-310004.4.1"></a>Strict versus Relaxed Step Size</h4>
<!--l. 648--><p class="noindent" >After comparing the figures that showed the predicted versus actual result, it is clear that the
strict step size implementation does a much better job at predicting the price movements and
future values. Occasionally it predicts the price will move in a more drastic way, but rarely does it
predict a movement in the opposite direction. Looking at the entire simulation, the short, strict
simulation had 95.6% accuracy and an RMS error of 7.9%. The short, relaxed simulation
had an accuracy of 58.0% and an RMS error of 19.8%. Results from the longer step
size are roughly the same, except for the long, relaxed RMS error which tops out at
1146.7%!
<!--l. 660--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">4.4.2   </span> <a 
 id="x1-320004.4.2"></a>Short versus Long Step Size</h4>
<!--l. 662--><p class="noindent" >In the analysis of the relaxed step size implementation, it is obvious that the shorter step gave a
more accurate result. The longer step size made the algorithm predict large movements, and it did
not provide much value. In the case of the strict step size implementation, the step size did not
seem to make too much of a difference. Both simulations produced very accurate results, and each
managed to occasionally over predict a movement.
<!--l. 671--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">4.4.3   </span> <a 
 id="x1-330004.4.3"></a>Regarding the Validity of the Strict Implementation</h4>
<!--l. 673--><p class="noindent" >After running simulations and looking at the data, the results of the strict implementation
looked too good to be true. It manages to very accurately predict price movements
and one would expect to see larger variations from such a simple implementation. The
                                                                                         
                                                                                         
first concern was to verify that the algorithm was in no way gaining access to future
information at each prediction, which was confirmed. This implementation was reviewed,
debugged, and no mistakes were found. However, that is not to say that this method
is ready to be used in accurately predicting all market movements. Extensive testing
needs to be done to verify if these finds are true or if there is an unfound mistake in the
model.
<!--l. 685--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">4.4.4   </span> <a 
 id="x1-340004.4.4"></a>Assessment of Trading Strategy</h4>
<!--l. 687--><p class="noindent" >Despite giving a prediction accuracy of 95%, all simulations of the strict, short implementation lost
money, while only AAPL had a positive return in the strict, long simulation. Given that the
ability to predict the price movement was so accurate, yet no profits were seen indicates
that the primitive trading strategy is inadequate. This trading strategy was simply
&#8220;buy if it will go up, sell if it is going to decrease&#8221;. A trading strategy that uses these
predictions and has a better understanding of when to place an order could be wildly
successful.
                                                                                         
                                                                                         
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;5</span><br /><a 
 id="x1-350005"></a>The Kalman Filter</h2>
<h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
 id="x1-360005.1"></a>Theory</h3>
<!--l. 702--><p class="noindent" >The Kalman Filter is a recursive algorithm that uses system measurements observed over time to
predict the value of future measurements. Each measurement is assumed to contain noise created
by a random variable in the process measurement. The algorithm has been shown to accurately
estimate the true value of such a process by minimizing the error introduced by the random
variables.
<!--l. 709--><p class="noindent" >In 1960 Rudolph E. Kalman published a widely read paper about the application of this algorithm
in discrete time sequences. Engineers in many fields adopted the algorithm, especially in topics
such as navigation and tracking. In this paper, we are looking to apply the Kalman
Filter algorithm in the context of tracking the price of a given security in the stock
market.
<!--l. 716--><p class="noindent" >With this goal in mind, we are presented with a unique challenge, namely that the Kalman Filter
algorithm requires a mathematical system model. When used in applications such as navigation or
tracking objects in space, kinematic system models can be experimentally designed since the
system measurements are governed by the laws of physics. In our case, there is no known
mathematical model of capital markets.
<!--l. 723--><p class="noindent" >As such, we have chosen to instead use a simplified version of the Kalman Filter called the
Alpha-Beta-Gamma Filter, which can be applied without the need for a rigorous mathematical
model. This algorithm is very similar to the Kalman Filter algorithm in theory. The
Alpha-Beta-Gamma Filter uses discrete time system measurements predict the value of future
measurements. However, is assumes a linear model, and can thus abstract the need for a more in
depth one.
<!--l. 731--><p class="noindent" >This filter has been shown to predict simple linear kinematic systems precisely, and
is categorized as a form of the State Observer in modern control theory. It works by
recursively incorporating the previous state measurement to produce a future estimate. After
each prediction and post-measurement, there is an update step wherein the algorithm
adjusts for the error between what it predicted and what the actual next measurement
was.
<!--l. 739--><p class="noindent" >Furthermore, the Alpha-Beta-Gamma Filter is named after the three greek letters which represent
algorithm parameters that determine how sensitive the algorithm is to large variations between
measurements. <span 
class="cmmi-12">&#x03B1; </span>is chosen by the user, then <span 
class="cmmi-12">&#x03B2; </span>and <span 
class="cmmi-12">&#x03B3; </span>are calculated from its value using the
following equations:
           <dl class="list1"><dt class="list">
<span 
class="cmmi-12">&#x03B1;</span>          </dt><dd 
class="list">
           <!--l. 745--><p class="noindent" >Chosen by the user, determines the sensitivity of the algorithm to error.
           </dd><dt class="list">
<span 
class="cmmi-12">&#x03B2;</span>          </dt><dd 
class="list">
           <!--l. 747--><p class="noindent" ><span 
class="cmr-12">2(2 </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">&#x03B1;</span><span 
class="cmr-12">) </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmr-12">4</span><img 
src="Paper11x.png" alt="&#x221A; ------
  1 - &#x03B1;"  class="sqrt" >
                                                                                         
                                                                                         
           </dd><dt class="list">
<span 
class="cmmi-12">&#x03B3;</span>          </dt><dd 
class="list">
           <!--l. 748--><p class="noindent" ><span 
class="cmmi-12">&#x03B2;</span><sup><span 
class="cmr-8">2</span></sup><span 
class="cmmi-12">&#x2215;</span><span 
class="cmr-12">(2</span><span 
class="cmmi-12">&#x03B1;</span><span 
class="cmr-12">)</span></dd></dl>
<!--l. 750--><p class="noindent" >See below for a detailed breakdown of the Alpha-Beta-Gamma Filter equations.
<!--l. 754--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">5.2   </span> <a 
 id="x1-370005.2"></a>Design</h3>
<!--l. 756--><p class="noindent" >In this project, we use the Alpha-Beta-Gamma Filter to predict the price of a given security at
time <span 
class="cmmi-12">t </span><span 
class="cmr-12">+ 1 </span>during a trading simulation. The algorithm works by adapting the price history into a
linear model with position, velocity and acceleration: <span 
class="cmmi-12">X</span>, <span 
class="cmmi-12">V, </span>and <span 
class="cmmi-12">A</span>, respectively. These parameters
are updated with each iteration and weighted with the <span 
class="cmmi-12">&#x03B1;</span>, <span 
class="cmmi-12">&#x03B2;</span>, and <span 
class="cmmi-12">&#x03B3; </span>factors to give an estimation of
the price for the next time step.
<!--l. 764--><p class="noindent" >We implemented an Alpha-Beta-Gamma Filter in Python using the Numpy open source library.
Numpy is a robust, highly versatile and widely used package for the Python programming
language that has functions for manipulating matrices and performing mathematical
calculations.
<!--l. 770--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">5.2.1   </span> <a 
 id="x1-380005.2.1"></a>Alpha-Beta-Gamma Filter Equations</h4>
<!--l. 772--><p class="noindent" >The following are the recursive equations that define the recursive algorithm.
<!--l. 775--><p class="noindent" ><span 
class="ecbx-1200">Prediction Equations</span>
<center class="par-math-display" >
<img 
src="Paper12x.png" alt="                    -
X  =  X - + V - + A-s-
  p     s    s     2
" class="par-math-display" ></center>
<!--l. 779--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper13x.png" alt="       -    -
Vp = Vs +  As
" class="par-math-display" ></center>
<!--l. 784--><p class="nopar" >
<!--l. 787--><p class="noindent" ><span 
class="ecbx-1200">Update Equations</span>
                                                                                         
                                                                                         
<center class="par-math-display" >
<img 
src="Paper14x.png" alt="            &#x02C6;
Residual =  X -  Xp
" class="par-math-display" ></center>
<!--l. 791--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper15x.png" alt="X  = X   + &#x03B1; * Residual
  s    p
" class="par-math-display" ></center>
<!--l. 796--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper16x.png" alt="Vs = Vp + &#x03B2; * Residual
" class="par-math-display" ></center>
<!--l. 801--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper17x.png" alt="       -
As = A s + &#x03B3; * Residual
" class="par-math-display" ></center>
<!--l. 806--><p class="nopar" >
<!--l. 809--><p class="noindent" >In these equations, we can see that a higher alpha value increases the responsiveness of the system
to residual error. This implies the system is more sensitive to prediction error, and a higher <span 
class="cmmi-12">&#x03B1; </span>value
should correspond with a more reactive system.
<!--l. 815--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">5.3   </span> <a 
 id="x1-390005.3"></a>Results</h3>
<!--l. 818--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">5.3.1   </span> <a 
 id="x1-400005.3.1"></a>Trading Simulation Specifications</h4>
<!--l. 819--><p class="noindent" >
           <dl class="list1"><dt class="list">
Data      </dt><dd 
class="list">
           <!--l. 820--><p class="noindent" >Equity price history
                                                                                         
                                                                                         
           </dd><dt class="list">
Period/Freq </dt><dd 
class="list">
           <!--l. 821--><p class="noindent" >1 year at 10 minute resolution. ~9000 data points per equity
           </dd><dt class="list">
Stocks     </dt><dd 
class="list">
           <!--l. 823--><p class="noindent" >Ford (F), Apple (AAPL), Accenture (ACN), Caterpillar (CAT), Macy&#8217;s (M),
           United Parcel Service (UPS), Priceline (PCLN), Campbell Soup Company (CPB)
           </dd><dt class="list">
Starting-capital </dt><dd 
class="list">
           <!--l. 826--><p class="noindent" >$100,000 (<span 
class="cmmi-12">C</span><sub><span 
class="cmmi-8">i</span></sub>)
           </dd><dt class="list">
<span 
class="cmmi-12">&#x03B1;</span>          </dt><dd 
class="list">
           <!--l. 827--><p class="noindent" >Range of [0 to 1]</dd></dl>
<!--l. 829--><p class="noindent" >Applying the Alpha-Beta-Gamma Filter as an estimator in the trading simulation gives mixed
results. In some cases the prediction was good enough to ultimately lead to profit, but many other
times it led to a net loss.
<!--l. 835--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">5.3.2   </span> <a 
 id="x1-410005.3.2"></a>Net Profit</h4>
<!--l. 837--><p class="noindent" >Net profit is calculated by taking the value of all cash and equity holdings (<span 
class="cmmi-12">A</span>) and subtracting the
starting capital ($100,000).
<center class="par-math-display" >
<img 
src="Paper18x.png" alt="P =  A - Ci
" class="par-math-display" ></center>
<!--l. 842--><p class="nopar" >
<!--l. 845--><p class="noindent" >The following is a comparison between the net profit achieved by applying the Alpha-Beta-Gamma
Filter with two different <span 
class="cmmi-12">&#x03B1; </span>values to 8 different securities.
<!--l. 849--><p class="noindent" ><span 
class="ecbx-1200">Graph of Net Profit where </span><span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">8</span>
<!--l. 851--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-41001r1"></a>
                                                                                         
                                                                                         

<!--l. 852--><p class="noindent" ><img 
src="9_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_Abg-NetProfit80.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.1: </span><span  
class="content">Net Profit <span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">8</span></span></div><!--tex4ht:label?: x1-41001r1 -->
                                                                                         
                                                                                         
<!--l. 855--><p class="noindent" ></div><hr class="endfigure">
<!--l. 858--><p class="noindent" >In this simulation, the alpha value was set to 0.8, meaning the filter was more sensitive to
prediction error. The result was an average net profit of $ 913.42, but the trade simulations for
Apple and Priceline yielded significant outliers. Removing these two data points gives an average
return of $ -367.43. Therefore, we conclude that the <span 
class="cmmi-12">&#x03B1;&#x03B2;&#x03B3; </span>Filter with an <span 
class="cmmi-12">&#x03B1; </span>of 0.8 is not an effective
estimator for this dataset.
<!--l. 866--><p class="noindent" ><span 
class="ecbx-1200">Graph of Total Net Returns where </span><span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">2</span>
<!--l. 868--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-41002r2"></a>
                                                                                         
                                                                                         

<!--l. 869--><p class="noindent" ><img 
src="10_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_Abg-NetProfit20.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.2: </span><span  
class="content">Net Profit <span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">2</span></span></div><!--tex4ht:label?: x1-41002r2 -->
                                                                                         
                                                                                         
<!--l. 872--><p class="noindent" ></div><hr class="endfigure">
<!--l. 875--><p class="noindent" >In this case the <span 
class="cmmi-12">&#x03B1; </span>value was set to 0.2, meaning the filter was less sensitive to prediction error. This
simulation yielded an average net profit of $ -180.22. After removing Apple and Priceline, our two
outliers, the average profit is calculated to be $ -480.29. Therefore an <span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">2 </span>is less optimal
compared to <span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">8 </span>for the trading simulation.
<!--l. 882--><p class="noindent" ><span 
class="ecbx-1200">Conclusions</span>
<!--l. 884--><p class="noindent" >Albeit this is a small sample size, the trading simulations above demonstrate that neither 0.8 or 0.2
generate positive net profit consistently. Although is possible that there is a more optimal <span 
class="cmmi-12">&#x03B1; </span>value
between 0 and 1, these results indicate that it is unlikely an optimal <span 
class="cmmi-12">&#x03B1; </span>value exists that will
generate profit consistently. The next section will explore the effect of <span 
class="cmmi-12">&#x03B1; </span>on the trading simulation
in more depth.
<h4 class="subsectionHead"><span class="titlemark">5.3.3   </span> <a 
 id="x1-420005.3.3"></a>Predicted Price vs. Actual Price</h4>
<!--l. 895--><p class="noindent" >The success of this algorithm for all practical purposes can be measured by how well the
algorithm predicts price movements. The <span 
class="cmmi-12">&#x03B1; </span>value will affect how sensitive the filter is to
prediction error. Thus, with a higher <span 
class="cmmi-12">&#x03B1; </span>value, we should expect that the filter may track
more quickly, at the expense of potentially overshooting the actual values. Conversely, a
smaller <span 
class="cmmi-12">&#x03B1; </span>should give smoother predictions at the expense of being sensitive to rapid
changes.
<!--l. 903--><p class="noindent" >The following is a comparison of a small section of the simulation between the predicted price vs.
actual price with two different <span 
class="cmmi-12">&#x03B1; </span>values on the <span 
class="cmmi-12">UPS </span>instrument.
<!--l. 907--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with </span><span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">8</span>
<!--l. 909--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-42001r3"></a>
                                                                                         
                                                                                         

<!--l. 910--><p class="noindent" ><img 
src="11_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_Abg-pred80.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.3: </span><span  
class="content">80 points of prediction with <span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">8 </span></span></div><!--tex4ht:label?: x1-42001r3 -->
<!--l. 915--><p class="noindent" >RMS-Error is found to be 0.1127
<!--l. 917--><p class="noindent" >Simulation predicted the direction of price fluctuations 85.23% of the time
                                                                                         
                                                                                         
<!--l. 919--><p class="noindent" ></div><hr class="endfigure">
<!--l. 922--><p class="noindent" >From the above graph, we can see that the filter closely follows the actual values except for a few
significant outliers. The effects of a high <span 
class="cmmi-12">&#x03B1; </span>in this case can be seen in how the jaggedness of the red
area line. Each time a prediction is significantly different from the actual value, the next prediction
makes a large correction.
<!--l. 928--><p class="noindent" >Interestingly, the simulation with this <span 
class="cmmi-12">&#x03B1; </span>value predicted the correct direction of the price change
(positive or negative) 85% of the time. With such a high success rate, we conclude that even a
small number of failed predictions can lead to significant losses.
<!--l. 933--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with </span><span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">2</span>
<!--l. 935--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-42002r4"></a>
                                                                                         
                                                                                         

<!--l. 936--><p class="noindent" ><img 
src="12_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_Abg-pred20.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.4: </span><span  
class="content">80 points of prediction with <span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">2 </span></span></div><!--tex4ht:label?: x1-42002r4 -->
<!--l. 941--><p class="noindent" >RMS-Error is found to be 0.1948
<!--l. 943--><p class="noindent" >Simulation predicted the direction of price fluctuations 63.61% of the time
                                                                                         
                                                                                         
<!--l. 945--><p class="noindent" ></div><hr class="endfigure">
<!--l. 948--><p class="noindent" >In this simulation with a low <span 
class="cmmi-12">&#x03B1;, </span>the predictions lag behind the actual values. This demonstrates
what we expect about <span 
class="cmmi-12">&#x03B1;</span>, namely that the low value corresponds with a smoother prediction curve
that is less sensitive to changes in the system. Accordingly, we see the red prediction line change
once the blue actual line has made a significant change.
<!--l. 955--><p class="noindent" >Not surprisingly, the lower <span 
class="cmmi-12">&#x03B1; </span>value produces a higher root mean square error in the predictions and
predicts correctly about 22% of the time.
<h3 class="sectionHead"><span class="titlemark">5.4   </span> <a 
 id="x1-430005.4"></a>Evaluation</h3>
<!--l. 963--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">5.4.1   </span> <a 
 id="x1-440005.4.1"></a>Choice of <span 
class="cmmi-12">&#x03B1; </span></h4>
<!--l. 965--><p class="noindent" >The choice of <span 
class="cmmi-12">&#x03B1; </span>can significantly alter the predictions in the trading simulation. This is because the
<span 
class="cmmi-12">&#x03B1; </span>value determines how sensitive the algorithm update equations are to the error produced at each
time step (see Alpha-Beta-Gamma Filter Equations). The figure below shows <span 
class="cmmi-12">&#x03B1;</span>&#8217;s effect on net
profit for the <span 
class="cmmi-12">UPS </span>instrument.
<!--l. 971--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-44001r5"></a>
                                                                                         
                                                                                         

<!--l. 972--><p class="noindent" ><img 
src="13_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_Abg-alphaAll.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.5: </span><span  
class="content">Effect of <span 
class="cmmi-12">&#x03B1; </span>on Net Profit for <span 
class="cmmi-12">UPS </span></span></div><!--tex4ht:label?: x1-44001r5 -->
<!--l. 977--><p class="noindent" >Discovered an optimal <span 
class="cmmi-12">&#x03B1; </span><span 
class="cmr-12">= 0</span><span 
class="cmmi-12">.</span><span 
class="cmr-12">96</span>
<!--l. 979--><p class="noindent" >Realized gain is $ 281.95
<!--l. 981--><p class="noindent" >Predicted the direction of price fluctuations 77.41% of the time
                                                                                         
                                                                                         
<!--l. 982--><p class="noindent" ></div><hr class="endfigure">
<!--l. 985--><p class="noindent" >These results show that very low <span 
class="cmmi-12">&#x03B1; </span>values create poor estimators in the trading simulation, but, <span 
class="cmmi-12">&#x03B1;</span>
values of 0.95, 0.96 and 0.97 produce positive net profit. This makes sense because the price of a
financial instrument is highly volatile. When a low <span 
class="cmmi-12">&#x03B1; </span>is used the estimator is less sensitive and fails
to respond quickly to price changes. In contrast, a high <span 
class="cmmi-12">&#x03B1; </span>value allows the estimator to track the
price more closely. Unfortunately, an <span 
class="cmmi-12">&#x03B1; </span>of 1 doesn&#8217;t perfectly predict the future instrument prices
because in many cases the estimator responds too quickly and too aggressively for an accurate
prediction.
<!--l. 996--><p class="noindent" >Theoretically, this filter is designed to estimate a simple system by modeling position, velocity and
acceleration. Empirically, these properties are not inherent to the capital markets, and thus the
algorithm struggles to accurately predict price movements.
<h4 class="subsectionHead"><span class="titlemark">5.4.2   </span> <a 
 id="x1-450005.4.2"></a>Conclusions</h4>
<!--l. 1004--><p class="noindent" >The Alpha-Beta-Gamma Filter is generally not a very effective estimator for capital market prices.
However, in some trading simulations the filter estimation led to net positive profit. We conclude
that this can be achieved by a combination of an optimal choice for <span 
class="cmmi-12">&#x03B1; </span>and some amount of luck /
coincidence.
                                                                                         
                                                                                         
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;6</span><br /><a 
 id="x1-460006"></a>Linear Estimation</h2>
<h3 class="sectionHead"><span class="titlemark">6.1   </span> <a 
 id="x1-470006.1"></a>Theory</h3>
<!--l. 1016--><p class="noindent" >Linear Prediction is a form of estimation used in linear discrete time systems. Linear prediction
models are used in a wide number of applications including predicting the behavior
of neural networks in biomedical engineering and digital signal processing in systems
engineering. On a high level, this model uses <span 
class="cmmi-12">n </span>data points to predict the <span 
class="cmmi-12">n </span><span 
class="cmr-12">+ 1 </span>&#8217;th
point.
<!--l. 1023--><p class="noindent" >The prediction model can be represented in matrix form as
<center class="math-display" >
<img 
src="Paper19x.png" alt="Sk =  R
" class="math-display" ></center>
<!--l. 1026--><p class="nopar" >
<!--l. 1028--><p class="noindent" >
           <dl class="list1"><dt class="list">
<span 
class="cmmi-12">S</span>          </dt><dd 
class="list">
           <!--l. 1029--><p class="noindent" >&#8220;Stimulus&#8221; <span 
class="cmmi-12">m </span>x <span 
class="cmmi-12">n </span>matrix
           </dd><dt class="list">
<span 
class="cmmi-12">R</span>          </dt><dd 
class="list">
           <!--l. 1030--><p class="noindent" >&#8220;Response&#8221; <span 
class="cmmi-12">m </span>x <span 
class="cmr-12">1 </span>vector
           </dd><dt class="list">
<span 
class="cmmi-12">k</span>          </dt><dd 
class="list">
           <!--l. 1031--><p class="noindent" ><span 
class="cmmi-12">n </span>x <span 
class="cmr-12">1 </span>Prediction Vector</dd></dl>
<!--l. 1033--><p class="noindent" >This is only notationally different from the standard matrix equation <span 
class="cmmi-12">Ax </span><span 
class="cmr-12">= </span><span 
class="cmmi-12">b</span>, which is
used commonly in linear algebra. In the linear prediction model, <span 
class="cmmi-12">S </span>is referred to as
the &#8220;stimulant&#8221; and <span 
class="cmmi-12">R </span>as the &#8220;response.&#8221; Right side matrix multiplication of <span 
class="cmmi-12">S </span>by <span 
class="cmmi-12">k</span>
gives the vector <span 
class="cmmi-12">R</span>. Accordingly, multiplication of any individual row of <span 
class="cmmi-12">S</span>, denoted as
<img 
src="Paper20x.png" alt="-&#x2192;
 S "  class="pic-halign" >                                                                                      , by <span 
class="cmmi-12">k </span>gives the corresponding
row in <span 
class="cmmi-12">R</span>, denoted as <img 
src="Paper21x.png" alt="-&#x2192;R  "  class="pic-halign" >                                                                                                 .
<!--l. 1041--><p class="noindent" >To create a prediction model in this form, we build <span 
class="cmmi-12">S </span>and <span 
class="cmmi-12">R </span>by taking stimulants and responses
from a dataset. In this paper we build this model using the price history of a stock. Each row
<img 
src="Paper22x.png" alt="-&#x2192;S "  class="pic-halign" >                                                                                      is constructed
by collecting <span 
class="cmmi-12">n </span>data points. Each successive row gathers <span 
class="cmmi-12">n </span>points shifting forward by a predetermined <span 
class="ecbx-1200">step</span>
<span 
class="ecbx-1200">length</span>. Each row <img 
src="Paper23x.png" alt="-&#x2192;
R  "  class="pic-halign" >
is constructed by collecting the 1st data point following the <span 
class="cmmi-12">n </span>points collected for
<img 
src="Paper24x.png" alt="-&#x2192;S "  class="pic-halign" >                                                                                      .
                                                                                         
                                                                                         
<!--l. 1049--><p class="noindent" >Mathematically where <span 
class="ecbx-1200">step length = </span><span 
class="cmmi-12">s</span><span 
class="ecbx-1200">:</span>
<center class="par-math-display" >
<img 
src="Paper25x.png" alt="-&#x2192;S1 = [ pi pi+1  ...  pi+n ]
" class="par-math-display" ></center>
<!--l. 1054--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper26x.png" alt="-R&#x2192;1 =  [ pi+n+1 ]
" class="par-math-display" ></center>
<!--l. 1060--><p class="nopar" >
<center class="math-display" >
<img 
src="Paper27x.png" alt="-&#x2192;
S2 = [ pi+s  pi+s+1  ...  pi+s+n ]
" class="math-display" ></center>
<!--l. 1064--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper28x.png" alt="-&#x2192;
R2 =  [ pi+s+n+1 ]
" class="par-math-display" ></center>
<!--l. 1070--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper29x.png" alt="-&#x2192;
Sm  = [ pi+ms   pi+ms+1  ...  pi+ms+n ]
" class="par-math-display" ></center>
<!--l. 1076--><p class="nopar" >
<center class="par-math-display" >
<img 
src="Paper30x.png" alt="-&#x2192;
Rm  = [ pi+ms+n+1 ]
" class="par-math-display" ></center>
<!--l. 1082--><p class="nopar" >
<center class="math-display" >
<img 
src="Paper31x.png" alt="
" class="math-display" ></center>
                                                                                         
                                                                                         
<!--l. 1084--><p class="nopar" >
<!--l. 1087--><p class="noindent" >Once we have computed <span 
class="cmmi-12">S </span>and <span 
class="cmmi-12">R</span>, then finding <span 
class="cmmi-12">k </span>is a simple matrix operation. It is possible to use
the formula <span 
class="cmmi-12">k </span><span 
class="cmr-12">= </span><span 
class="cmmi-12">S</span><sup><span 
class="cmsy-8">-</span><span 
class="cmr-8">1</span></sup><span 
class="cmmi-12">R </span>to find <span 
class="cmmi-12">k</span>, but we use a more accurate method, which minimizes the error
introduced in the calculation. Skipping the derivation of this formula, the equation is as
follows:
<center class="par-math-display" >
<img 
src="Paper32x.png" alt="       T  - 1 T
k = (S  S )  S R
" class="par-math-display" ></center>
<!--l. 1095--><p class="nopar" >
<!--l. 1098--><p class="noindent" >Then, <span 
class="cmmi-12">k </span>can be applied to any <span 
class="cmmi-12">n </span>x <span 
class="cmr-12">1 </span>vector of consecutive data points to compute the
corresponding response. In practice, the linear model is constructed based on known training data.
Then, it is applied to observed data to predict future measurements. See the &#8220;Design&#8221; section to see
how the filter is applied in this paper.
<!--l. 1105--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
 id="x1-480006.2"></a>Design</h3>
<!--l. 1107--><p class="noindent" >The design of the linear prediction model for our trading algorithm can be best understood by
examining the example below (see sub-section .1).
<!--l. 1111--><p class="noindent" >Implementing the linear prediction model for our trading algorithm required a few design choices.
First, we chose our <span 
class="ecbx-1200">step length </span>to be 1. Generally, unless computation time is a serious problem,
linear prediction models should use the smallest possible increment in order to maximize the
accuracy of the estimator, <span 
class="cmmi-12">k</span>.
<!--l. 1117--><p class="noindent" >Second, we had to choose what our <span 
class="ecbx-1200">filter length </span>would be. This is the number of data points
selected to predict the following single point. For comparison, we chose two lengths: 1000 and 2000.
A longer filter length generally corresponds with a longer computation time, but more accurate
predictions.
<!--l. 1123--><p class="noindent" >Lastly, we chose to build the linear prediction model from the <span 
class="ecbx-1200">first half </span>of the data
and trade on the second half. This way, we can most closely simulate a real trading
strategy.
<!--l. 1128--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.2.1   </span> <a 
 id="x1-490006.2.1"></a>Linear Model Example</h4>
<!--l. 1130--><p class="noindent" >Take the following price history for a stock <span 
class="ecbx-1200">F:</span>
<!--l. 1132--><p class="noindent" ><span 
class="ecbx-1200">Data: </span>[14.5, 15, 14.8, 15.2, 15.7, 16.5, 15.6, 14.3, 14.0, 14.4, 14.9, 15.9]
                                                                                         
                                                                                         
<!--l. 1135--><p class="noindent" ><span 
class="ecbx-1200">Graph:</span>
<!--l. 1137--><p class="noindent" ><img 
src="14_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_lin-prices-small.png" alt="PIC"  
>
<!--l. 1139--><p class="noindent" >Take <span 
class="cmmi-12">n </span><span 
class="cmr-12">= 3 </span>and the <span 
class="ecbx-1200">step length = </span><span 
class="cmr-12">1</span><span 
class="ecbx-1200">.</span>
<!--l. 1141--><p class="noindent" ><span 
class="cmmi-12">S </span>is constructed as follows:
<center class="par-math-display" >
<img 
src="Paper33x.png" alt="     &#x230A; 14.5   15   14.8 &#x230B;
     ||  15   14.8  15.2 ||
S =  |                  |
     &#x2308; 14.8  15.2  15.7 &#x2309;
        ...    ...    ...
" class="par-math-display" ></center>
<!--l. 1150--><p class="nopar" >
<!--l. 1153--><p class="noindent" >The first row is the first three elements of <span 
class="ecbx-1200">Data</span>; the second row is the following three elements of
<span 
class="ecbx-1200">Data</span>; etc...
<!--l. 1156--><p class="noindent" ><span 
class="cmmi-12">R </span>is constructed as follows:
<center class="par-math-display" >
<img 
src="Paper34x.png" alt="     &#x230A;  15  &#x230B;
     || 15.7 ||
R =  |      |
     &#x2308; 16.5 &#x2309;
        ...
" class="par-math-display" ></center>
<!--l. 1165--><p class="nopar" >
<!--l. 1168--><p class="noindent" >The first element in <span 
class="cmmi-12">R </span>is the fourth element of <span 
class="ecbx-1200">Data</span>; the second element of <span 
class="cmmi-12">R </span>is the fifth element
of <span 
class="ecbx-1200">Data</span>; etc...
<!--l. 1172--><p class="noindent" >We know <span 
class="cmmi-12">S </span>and <span 
class="cmmi-12">R</span>, and we seek to solve for the value of <span 
class="cmmi-12">k</span>.
<center class="par-math-display" >
<img 
src="Paper35x.png" alt="    &#x230A;  k1 &#x230B;
    ||  k  ||
k = |   2 |
    &#x2308;  ... &#x2309;
       kn
" class="par-math-display" ></center>
<!--l. 1181--><p class="nopar" >
<!--l. 1184--><p class="noindent" >Then, we can confirm that if we multiply any row of <span 
class="cmmi-12">S </span>by <span 
class="cmmi-12">k</span>, we will get the corresponding value in
<span 
class="cmmi-12">R</span>.
                                                                                         
                                                                                         
<center class="par-math-display" >
<img 
src="Paper36x.png" alt="
" class="par-math-display" ></center>
<!--l. 1194--><p class="nopar" >
<center class="math-display" >
<img 
src="Paper37x.png" alt="                  &#x230A;    &#x230B;
[               ] | k1 |
  14.5  15   14.8   &#x2308; k2 &#x2309; = 15
                    k3
" class="math-display" ></center>
<!--l. 1202--><p class="nopar" >
<!--l. 1206--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
 id="x1-500006.3"></a>Results</h3>
<!--l. 1209--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.1   </span> <a 
 id="x1-510006.3.1"></a>Trading Simulation Specifications</h4>
<!--l. 1210--><p class="noindent" >
           <dl class="list1"><dt class="list">
Data      </dt><dd 
class="list">
           <!--l. 1211--><p class="noindent" >Equity price history
           </dd><dt class="list">
Period/Freq </dt><dd 
class="list">
           <!--l. 1212--><p class="noindent" >1 year at 10 minute resolution. ~9000 data points per equity
           </dd><dt class="list">
Stocks     </dt><dd 
class="list">
           <!--l. 1214--><p class="noindent" >Ford (F), Apple (AAPL), Accenture (ACN), Caterpillar (CAT), Macy&#8217;s (M),
           United Parcel Service (UPS), Priceline (PCLN), Campbell Soup Company (CPB)
                                                                                         
                                                                                         
           </dd><dt class="list">
Starting-capital </dt><dd 
class="list">
           <!--l. 1217--><p class="noindent" >$100,000 (<span 
class="cmmi-12">C</span><sub><span 
class="cmmi-8">i</span></sub>)
           </dd><dt class="list">
Filter-length </dt><dd 
class="list">
           <!--l. 1218--><p class="noindent" >1000 and 2000
           </dd><dt class="list">
Step-length </dt><dd 
class="list">
           <!--l. 1219--><p class="noindent" >1 time step</dd></dl>
<!--l. 1222--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.3.2   </span> <a 
 id="x1-520006.3.2"></a>Net Profit</h4>
<!--l. 1224--><p class="noindent" >Net profit is calculated by taking the value of all cash and equity holdings (<span 
class="cmmi-12">A</span>) and subtracting the
starting capital ($100,000).
<center class="par-math-display" >
<img 
src="Paper38x.png" alt="P =  A - C
           i
" class="par-math-display" ></center>
<!--l. 1229--><p class="nopar" >
<!--l. 1232--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with filter length 1000</span>
<!--l. 1234--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-52001r1"></a>
                                                                                         
                                                                                         

<!--l. 1235--><p class="noindent" ><img 
src="15_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_lin-prof-1000.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.1: </span><span  
class="content">Net Profit filter length 1000</span></div><!--tex4ht:label?: x1-52001r1 -->
                                                                                         
                                                                                         
<!--l. 1238--><p class="noindent" ></div><hr class="endfigure">
<!--l. 1241--><p class="noindent" >This simulation yielded an average net profit of $ -1724.28, but the results from Apple and
Priceline significantly affected the average. When these two outliers are removed, as they are done
for the alpha-beta-gamma filter, the average becomes $ 1.23. This result indicates that the linear
prediction model is a decent estimator for the trading simulation. Of course, a larger
sample size would offer stronger results, but with the resources at hand, this result is
positive.
<!--l. 1249--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with filter length 2000</span>
<!--l. 1251--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-52002r2"></a>
                                                                                         
                                                                                         

<!--l. 1252--><p class="noindent" ><img 
src="16_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_lin-prof-2000.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.2: </span><span  
class="content">Net Profit filter length 2000</span></div><!--tex4ht:label?: x1-52002r2 -->
                                                                                         
                                                                                         
<!--l. 1255--><p class="noindent" ></div><hr class="endfigure">
<!--l. 1258--><p class="noindent" >This simulation with a filter length of 2000 yielded an average net profit of $ -1122.52, but similar
to the first simulation Apple and Price are outliers. Removing these shows an average profit of
$ -55.70. This result is slightly more negative than the filter length of 1000, but still
promising.
<h4 class="subsectionHead"><span class="titlemark">6.3.3   </span> <a 
 id="x1-530006.3.3"></a>Predicted Price vs. Actual Price</h4>
<!--l. 1267--><p class="noindent" >As for the other algorithms in this paper, the success of any of our estimations can be measured
by how well it predicts price movements. The more it does it correctly, the more net
profit we gain during a simulation. Based on the theory of the linear prediction model,
we expect that a longer filter length leads to more accurate predictions and more net
profit.
<!--l. 1274--><p class="noindent" >What follows is a <span 
class="ecbx-1200">60 point comparison </span>between the predicted price vs. actual price with
two different filter lengths. For the sake of clarity, only a small section of the data is
shown.
<!--l. 1278--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with filter length 1000</span>
<!--l. 1280--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-53001r3"></a>
                                                                                         
                                                                                         

<!--l. 1281--><p class="noindent" ><img 
src="17_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_lin-pred-1000.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.3: </span><span  
class="content">Prediction with 1000 filter length</span></div><!--tex4ht:label?: x1-53001r3 -->
<!--l. 1286--><p class="noindent" >RMS-Error is found to be 0.0671
<!--l. 1288--><p class="noindent" >Simulation predicted the direction of price fluctuations 70.04% of the time
                                                                                         
                                                                                         
<!--l. 1290--><p class="noindent" ></div><hr class="endfigure">
<!--l. 1293--><p class="noindent" >The results from the above simulation show the linear predictions follow the real prices and predict
correct price movements 70% of the time. Ultimately, this simulation didn&#8217;t break even, but
empirically it looks like a modification in the filter length may produce even more accurate
results.
<!--l. 1299--><p class="noindent" ><span 
class="ecbx-1200">Simulation Results with filter length 2000</span>
<!--l. 1301--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-53002r4"></a>
                                                                                         
                                                                                         

<!--l. 1302--><p class="noindent" ><img 
src="18_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_lin-pred-2000.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.4: </span><span  
class="content">Prediction with 2000 filter length</span></div><!--tex4ht:label?: x1-53002r4 -->
<!--l. 1307--><p class="noindent" >RMS-Error is found to be 0.1526
<!--l. 1309--><p class="noindent" >Simulation predicted the direction of price fluctuations 60.01% of the time
                                                                                         
                                                                                         
<!--l. 1311--><p class="noindent" ></div><hr class="endfigure">
<!--l. 1314--><p class="noindent" >With a filter length of 2000, this trading simulation performed noticeably worse than the
simulation with the shorter filter. The effect of using a longer filter is not surprising since it means
that 2000 points are used to predict 1 future point. These results make sense because a longer filter
should be less sensitive to small changes in price.
<h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
 id="x1-540006.4"></a>Evaluation</h3>
<!--l. 1324--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.4.1   </span> <a 
 id="x1-550006.4.1"></a>Effect of filter length </h4>
<!--l. 1326--><p class="noindent" >The filter length is the number of points that are used to predict one single point in the
future. Intuitively, one may think that the longest possible filter length would yield the
greatest results. Our results prove that this is not necessarily the case with financial
instruments.
<!--l. 1332--><p class="noindent" >In fact, an analysis of the effect of filter length on four of our financial instruments reveals that
short filter length between 200 and 800 are generally more optimal parameters.
<!--l. 1336--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-55001r5"></a>
                                                                                         
                                                                                         

<!--l. 1337--><p class="noindent" ><img 
src="19_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_lin-vary-ups.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.5: </span><span  
class="content">Varying filter length for UPS</span></div><!--tex4ht:label?: x1-55001r5 -->
                                                                                         
                                                                                         
<!--l. 1340--><p class="noindent" ></div><hr class="endfigure">
<!--l. 1343--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-55002r6"></a>
                                                                                         
                                                                                         

<!--l. 1344--><p class="noindent" ><img 
src="20_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_lin-vary-ACN.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;6.6: </span><span  
class="content">Varying filter length for ACN</span></div><!--tex4ht:label?: x1-55002r6 -->
                                                                                         
                                                                                         
<!--l. 1347--><p class="noindent" ></div><hr class="endfigure">
<h4 class="subsectionHead"><span class="titlemark">6.4.2   </span> <a 
 id="x1-560006.4.2"></a>Time Complexity Trade-Offs</h4>
<!--l. 1353--><p class="noindent" >An important note to be considered with the linear prediction model is the tradeoff between filter
length and time complexity. A longer filter length is directly proportional to a longer time-to-run.
This is a result of the intense mathematical calculations that take place performing matrix
operations with the large matrices in this problem. Such long runtimes would make this
an infeasible option for real time prediction, except that all of the calculation time is
pre-processing.
<!--l. 1362--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">6.4.3   </span> <a 
 id="x1-570006.4.3"></a>Feasibility as an estimator</h4>
<!--l. 1364--><p class="noindent" >The linear prediction model revealed some of the most promising results of this evaluation. In fact,
for UPS and PCLN, this algorithm mostly produced net positive results. However, this is offset by
producing equally poor results for other simulations. Further testing may reveal the cause of
success or failure for this algorithm, but for the scope of this paper, we are not able to conclude it
is either good or bad, only that it is a stronger estimator than some of the other algorithms
presented here.
                                                                                         
                                                                                         
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;7</span><br /><a 
 id="x1-580007"></a>Conclusions</h2>
<h3 class="sectionHead"><span class="titlemark">7.1   </span> <a 
 id="x1-590007.1"></a>Algorithm Comparison</h3>
<!--l. 1379--><p class="noindent" >The following table compares the performance of the algorithms in this paper. The results are not
optimal cases, rather comparable cases used the in the analysis of net profit in each
section.
<!--l. 1383--><p class="noindent" ><hr class="figure"><div class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x1-59001r1"></a>
                                                                                         
                                                                                         

<!--l. 1384--><p class="noindent" ><img 
src="21_Users_dduggan_Dropbox_Wash_U_Senior_Year_senior_design_images_comptable.png" alt="PIC"  
>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;7.1: </span><span  
class="content">Algorithm Comparison trading the UPS instrument</span></div><!--tex4ht:label?: x1-59001r1 -->
                                                                                         
                                                                                         
<!--l. 1387--><p class="noindent" ></div><hr class="endfigure">
                                                                                         
                                                                                         
<h2 class="likechapterHead"><a 
 id="x1-600007.1"></a>Bibliography</h2>
                      <div class="thebibliography">
                      <p class="bibitem" ><span class="biblabel">
 [WallStreetAndTech]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xkey-2"></a>Ioti, Rob. "The Real Story of Trading Software Espionage." Wall
                      Street and Technology. Wall Street and Technology, 10 July 2009. Web.
                      12 Dec. 2013.
                      </p>
                      <p class="bibitem" ><span class="biblabel">
 [AlgorithmicTrading]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xkey-3"></a>"Algorithmic  Trading."  Wikipedia.  Wikimedia  Foundation,  12
                      Oct. 2013. Web. 12 Dec. 2013.
</p>
                      </div>
                                                                                         
                                                                                         
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;8</span><br /><a 
 id="x1-610008"></a>Code</h2>
<h3 class="sectionHead"><span class="titlemark">8.1   </span> <a 
 id="x1-620008.1"></a>Alpha Beta Gamma Filter</h3>
 
</body></html> 

                                                                                         


